Core 
    init - consts - base - components
    Bu katman bussines katmanlarının yapılacağı işlerin yönetildiği yer
    Bu katmanı taşıyabilmek önemli olandır yani başka bir projeye olduğu gibi taşıyabilmelisin

Test Core
    mock manager mock service

    Mock


streamBuilder?
    bir yeri dinliyor sadece dinlediği yerden gelene göre tetikleniyor



state class ?


reflection?


with ?
mixin abstract implements extends 
extension : o sınıfa özellik kazandırıyor, on dediğin sınıfı genişletiyor o sınıfa custom kendi özelliğini ekleyip nesnesi olmadan kullanabiliyorsun
store ? 
context ?
oNGenerateRoute ? 
SingleChildWidget ?
copywith? 
reflection?
@immutable?
pods?
podfile?
 WidgetsFlutterBinding.ensureInitialized(); ??
 migration ?
 equatable ? 
 searchDelegate ?
 goRouter and routing navigator 3.0
image_picker ? 
super ?
abstract, extends, implements
valueSetter

object vs dynamic 

factory

Navigator

mobx-mobx_codegen-flutter_mobx-build-runner






extension
snippet
singleton
fiximport 

WidgetsBinding.instance.addPostFrameCallback =>build metodu tamamlandıktan sonra Widget ağacı oluşur biter sonra işleme alınır 
future.microtask => Diğer future işlemlerinden önce işlenir


panache**



user işlemleri
stless işlemleri











// class _HomeListView extends StatelessWidget {
//   _HomeListView();

//   final CollectionReference coffees =
//       FirebaseFirestore.instance.collection('coffees');

//   @override
//   Widget build(BuildContext context) {
//     final response = coffees.withConverter(
//       fromFirestore: (snapshot, options) {
//         return Coffee().fromFirebase(snapshot);
//       },
//       toFirestore: (value, options) {
//         return value.toJson;
//       },
//     ).get();

//     return FutureBuilder(
//       future: response,
//       builder: (BuildContext context,
//           AsyncSnapshot<QuerySnapshot<Coffee?>> snapshot) {
//         switch (snapshot.connectionState) {
//           case ConnectionState.none:
//             return const Placeholder();
//           case ConnectionState.waiting:
//             return const LinearProgressIndicator();
//           case ConnectionState.active:
//             return const LinearProgressIndicator();
//           case ConnectionState.done:
//             if (snapshot.hasData) {
//               List<Coffee?> values = snapshot.data?.docs
//                       .map(
//                         (e) => e.data(),
//                       )
//                       .toList() ??
//                   [];
//               return ListView.builder(
//                 itemCount: values.length,
//                 itemBuilder: (BuildContext context, int index) {
//                   return Card(
//                     child: Column(
//                       children: [
//                         Image.network(
//                           values[index]!.backgroundImage!,
//                           height: 100,
//                           width: 100,
//                         ),
//                         Text(values[index]?.title ?? '')
//                       ],
//                     ),
//                   );
//                 },
//               );
//             } else {
//               return Container(height: 100, width: 100, color: Colors.red);
//             }
//         }
//       },
//     );
//   }
// }



Performans Optimizasyonu: Sınıflar, daha ayrıntılı yeniden oluşturma ve const yapıcıları sayesinde performans optimizasyonu sağlar.
Güncellemeler ve Bellek Yönetimi: Sınıflar, geçişler sırasında kaynakların doğru şekilde serbest bırakılmasını sağlar.